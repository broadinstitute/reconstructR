#' Visualize MCMC Output
#'
#' This function plots the log-likelihood, transmission network graph, and transmission probability chart.
#'
#' @param results MCMC output as generated by run_mcmc.
#' @param burnin We discard the first (burnin * 100) percent of the results
#' @return Three plots.
#' @export

# MIT License
#
# Copyright (c) 2023 Ivan Specht
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
#   The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

visualize <- function(
    results,
    burnin = 0.1 # we should discard the first (burnin * 100) percent of the results
){

  N <- results[[1]]$N
  reads <- results[[1]]$reads

  tot_lik <- c()
  adj <- matrix(0, nrow = N, ncol = N)

  for (i in 1:length(results)) {
    tot_lik[i] <- sum(results[[i]]$g_lik) + results[[i]]$e_lik + sum(results[[i]]$u_lik)
    if(i > burnin*length(results)){
      inds <- cbind(results[[i]]$anc[2:N], 2:N)
      adj[inds] <- adj[inds] + 1
    }
  }

  plot(tot_lik, xlab = "Iteration", ylab = "Log-Likelihood")



  adj <- adj / (sum(1:length(results) > burnin*length(results)))


  g <- igraph::graph_from_adjacency_matrix(adj[2:N, 2:N], weighted = T)
  igraph::E(g)$color <- rgb(0,0,0,igraph::E(g)$weight)
  coords <- igraph::layout_nicely(g)

  plot(
    g,
    layout = coords,
    edge.width = 3,
    edge.arrow.size = 0.5,
    vertex.size = 6,
    vertex.label = paste(2:N)
  )

    adj_melt <- reshape2::melt(adj)
    adj_melt <- adj_melt[adj_melt$value > 0, ]
    colnames(adj_melt) <- c("From", "To", "Probability")
    adj_melt$Distance <- mapply(get_cons_dist, adj_melt$From, adj_melt$To, MoreArgs = list(reads=reads))
    adj_melt$Overlap <- mapply(get_overlap, adj_melt$From, adj_melt$To, MoreArgs = list(reads=reads))
    adj_melt$Shared_iSNV <- mapply(get_shared_isnv, adj_melt$From, adj_melt$To, MoreArgs = list(reads=reads))
    adj_melt$Passed_iSNV <- adj_melt$Overlap & (adj_melt$Distance > 0)
    adj_melt$Relationship <- mapply(summarize, adj_melt$From, adj_melt$To, MoreArgs = list(reads=reads))
    adj_melt[,1] <- paste(adj_melt[,1])
    adj_melt[,2] <- paste(adj_melt[,2])
    adj_melt[,1][adj_melt[,1] == "1"] <- "Index"

    # Get colors for dots
    colors <- c("#BBBBBB", "#222222", "#2255BB", "#BB55BB","#22BB55", "#EEBB22")

    ggplot2::ggplot(adj_melt, ggplot2::aes(x = From, y = To, size = Probability, color = Relationship)) +
      ggplot2::geom_point() +
      ggplot2::scale_x_discrete(limits = c("Index", paste(2:N))) +
      ggplot2::scale_y_discrete(limits = c(paste(2:N))) +
      ggplot2::scale_color_manual(
        limits = c(
          "Index Case",
          "Undetected Consensus Change",
          "Same Consensus",
          "Fixation to Minor Allele",
          "Minor Allele to Fixation",
          "Split Bottleneck"
          ),
        values = colors) +
      ggplot2::theme_minimal()

}





